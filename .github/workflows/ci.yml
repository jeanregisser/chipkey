name: CI/CD

on:
  push:
    branches: [main]
  pull_request:

permissions:
  contents: write

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
      - uses: golangci/golangci-lint-action@v6
        with:
          version: v2.10.1
      - name: Check go mod tidy
        run: make check-tidy
      - name: Validate goreleaser config
        uses: goreleaser/goreleaser-action@v6
        with:
          args: check

  test:
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
      - run: go test -v ./...  # not using make: windows-latest lacks make

  version:
    needs: [lint, test]
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.resolve.outputs.version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for existing tag on HEAD
        id: existing
        run: |
          EXISTING=$(git tag --points-at HEAD | grep '^v' | head -1)
          if [ -n "$EXISTING" ]; then
            echo "Found existing tag: $EXISTING"
            echo "version=${EXISTING#v}" >> "$GITHUB_OUTPUT"
          fi

      - name: Determine next version
        if: steps.existing.outputs.version == ''
        id: semver
        uses: go-semantic-release/action@v1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          dry: true
          allow-initial-development-versions: true
          force-bump-patch-version: true

      - name: Resolve version
        id: resolve
        run: |
          VERSION="${{ steps.existing.outputs.version || steps.semver.outputs.version }}"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Resolved version: $VERSION"

      - name: Create and push tag
        if: steps.existing.outputs.version == '' && steps.resolve.outputs.version != ''
        run: |
          git tag "v${{ steps.resolve.outputs.version }}"
          git push origin "v${{ steps.resolve.outputs.version }}"

  release:
    needs: version
    if: needs.version.outputs.version != ''
    runs-on: macos-latest
    env:
      VERSION: ${{ needs.version.outputs.version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      - name: Run goreleaser
        uses: goreleaser/goreleaser-action@v6
        with:
          args: release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check signing secrets
        id: signing
        env:
          CERT: ${{ secrets.APPLE_CERTIFICATE_P12_BASE64 }}
        run: |
          if [ -n "$CERT" ]; then
            echo "available=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Import Apple certificate
        if: steps.signing.outputs.available == 'true'
        env:
          APPLE_CERTIFICATE_P12_BASE64: ${{ secrets.APPLE_CERTIFICATE_P12_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          CERTIFICATE_PATH="$RUNNER_TEMP/certificate.p12"
          KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -base64 32)"

          echo -n "$APPLE_CERTIFICATE_P12_BASE64" | base64 --decode -o "$CERTIFICATE_PATH"

          # Check certificate expiry before importing
          EXPIRY=$(openssl pkcs12 -in "$CERTIFICATE_PATH" -passin "pass:$APPLE_CERTIFICATE_PASSWORD" \
            -nokeys -clcerts 2>/dev/null | openssl x509 -noout -enddate 2>/dev/null | cut -d= -f2)
          if [ -n "$EXPIRY" ]; then
            EXPIRY_EPOCH=$(date -j -f "%b %d %T %Y %Z" "$EXPIRY" +%s 2>/dev/null || date -d "$EXPIRY" +%s 2>/dev/null)
            NOW_EPOCH=$(date +%s)
            DAYS_LEFT=$(( (EXPIRY_EPOCH - NOW_EPOCH) / 86400 ))
            echo "Certificate expires: $EXPIRY ($DAYS_LEFT days remaining)"
            if [ "$DAYS_LEFT" -lt 0 ]; then
              echo "::error::Apple Developer ID certificate has EXPIRED."
              echo "::error::Re-export from Keychain Access, base64-encode, and update the APPLE_CERTIFICATE_P12_BASE64 secret."
              echo "::error::If the certificate itself expired, create a new one at https://developer.apple.com/account/resources/certificates"
              exit 1
            elif [ "$DAYS_LEFT" -lt 30 ]; then
              echo "::warning::Apple Developer ID certificate expires in $DAYS_LEFT days ($EXPIRY)."
              echo "::warning::Prepare a replacement: export from Keychain Access and update the APPLE_CERTIFICATE_P12_BASE64 secret."
            fi
          fi

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security import "$CERTIFICATE_PATH" -P "$APPLE_CERTIFICATE_PASSWORD" \
            -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple: \
            -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychain -d user -s "$KEYCHAIN_PATH"

      - name: Build signed .app bundle
        if: steps.signing.outputs.available == 'true'
        run: |
          mkdir -p bin
          cp dist/chipkey_darwin_all/chipkey bin/chipkey-darwin
          make bundle APP_VERSION="$VERSION"

      - name: Upload .app bundle to release
        if: steps.signing.outputs.available == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cd bin
          zip -r "Chipkey_${VERSION}_macos_app.zip" Chipkey.app
          shasum -a 256 "Chipkey_${VERSION}_macos_app.zip" >> ../dist/checksums.txt
          gh release upload "v${VERSION}" "Chipkey_${VERSION}_macos_app.zip" ../dist/checksums.txt --clobber
